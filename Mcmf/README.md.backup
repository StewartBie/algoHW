# 最小费用最大流（MCMF）算法实现

本文档说明 `mcmf.c` 的算法设计思路、输入输出格式、运行方法以及复杂度分析。

## 算法概述

本程序实现最小费用最大流（Min-Cost Max-Flow）算法，采用 **SPFA + 连续增广** 策略：
- 每轮使用 SPFA（队列优化的 Bellman-Ford）在残量图中寻找最小费用增广路径
- 沿找到的路径增广尽可能多的流量
- 重复直到无增广路径

## 算法设计思路

### 核心思想

1. **残量图表示**：
   - 使用并行数组实现的邻接表存储图
   - 每条原始边 u→v 同时插入正向边（容量 c，费用 w）和反向边（容量 0，费用 -w）
   - 反向边用于记录已推送的流量，支持流的回退

2. **最小费用路径搜索**：
   - 使用 SPFA 算法在残量图中寻找从源点到汇点的最小费用路径
   - SPFA 能处理负权边，适合 MCMF 场景
   - 维护 dist[] 记录最小费用，prevv[]/preve[] 记录前驱路径

3. **流量增广**：
   - 沿找到的最小费用路径回溯，计算瓶颈容量（路径上最小剩余容量）
   - 沿路径更新正向边和反向边的容量
   - 累加流量和费用

### 数据结构设计

**邻接表（并行数组实现）**：
```c
int *head;      // head[u] = 节点 u 的第一条边索引，-1 表示无边
int *to_;       // to_[e] = 边 e 的终点
int *next_;     // next_[e] = 与边 e 同起点的下一条边索引
int *cap_;      // cap_[e] = 边 e 的剩余容量
ll *cost_;      // cost_[e] = 边 e 的单位费用
```

**优势**：
- 内存布局紧凑，缓存友好
- 只遍历实际存在的边，对稀疏图高效
- 按位异或快速访问反向边：`e^1` 是边 `e` 的反向边

## 输入输出格式

### 输入格式

标准输入格式（stdin）：

第一行：`n m`  — 顶点数 n、边数 m（节点编号假定为从0开始的 ）

接下来 m 行，每行一条边：`u v cap cost`

- `u`、`v`：起点和终点（整型，0-based）
- `cap`：整型，边的容量
- `cost`：长整型，单位流量费用

最后一行：`s t` — 源点与汇点（0-based）

Example：

```
4 4
0 1 3 1
1 3 2 2
0 2 2 2
2 3 2 1
0 3
```

输出：两个整数 `flow cost`，分别表示最大流和对应的最小总费用，例如 `4 12`。

---

## 三、主要数据结构（全局）

- `int N`：顶点数。
- 邻接表（并行数组实现）：
  - `int *head`：`head[u]` 指向以 `u` 为起点的第一条边的索引；`-1` 表示无出边。
  - `int *to_`：`to_[e]` 为边 `e` 的终点。
  - `int *next_`：`next_[e]` 为与 `e` 同起点的下一条边的索引（链表指针）。
  - `int *cap_`：`cap_[e]` 为边 `e` 的剩余容量。
  - `long long *cost_`：`cost_[e]` 为边 `e` 的单位费用；反向边存 `-cost`。
  - `int edge_cnt`：当前边数组中已使用的条目数量。（每插入一条原始边实际插入两条数组项：正向与反向。）

备注：程序在启动时根据输入的 `m` 调用 `ensure_edge_alloc(m)` 为并行数组分配 `2*m+5` 的空间，未实现动态扩容。

---

## 四、主要函数说明

- `void ensure_edge_alloc(int m2)`
  - 作用：为边的并行数组一次性分配空间（大小为 `2*m2 + 5`）。
  - 注意：仅在第一次调用时分配，不会动态 `realloc`，因此应确保传入的 `m2` 足够。

- `void add_edge(int u, int v, int c, ll w)`
  - 作用：向图中添加有向边 `u->v`（容量 `c`，单位费用 `w`），同时添加反向边 `v->u`（容量 `0`，费用 `-w`）。
  - 实现细节：使用并行数组 `to_`/`cap_`/`cost_`/`next_`，并通过 `head[u]` 链式连接。

- `void heap_push(ll d, int v)` / `Pair heap_pop()`
  - 作用：二叉堆实现的最小优先队列，原先用于 Dijkstra 的版本（现在代码主路径不再用 Dijkstra，但堆实现保留）。
  - 特性：不支持 decrease-key，采用重复插入并在弹出时通过比对 `dist[v]` 跳过过时条目。

- `void min_cost_max_flow(int s, int t, long long *out_flow, long long *out_cost)`
  - 作用：核心函数，计算从 `s` 到 `t` 的最大流及对应最小费用。当前实现采用 SPFA（基于队列）每轮寻找最小费用增广路径，并沿路径增广尽可能多的流量。
  - 主要局部数组：
    - `dist[]`：SPFA 维护的最小费用距离（从 `s` 到各点的费用）。
    - `prevv[]` / `preve[]`：用于记录最短路树，`prevv[v]` 为 `v` 的前驱顶点，`preve[v]` 为到达 `v` 的边索引。
    - `inqueue[]`：标记顶点是否在队列中，避免重复入队。
  - 算法流程（高层）：
    1. 初始化 `dist` 为 +INF，`dist[s]=0`，将 `s` 入队。
    2. 用队列执行松弛（SPFA）：对于队列中顶点 `v`，遍历其出边 `e`，若 `cap_[e] > 0` 且 `dist[to] > dist[v] + cost_[e]`，则更新并将 `to` 入队。
    3. 若 `t` 不可达（`prevv[t] == -1`），算法结束；否则沿 `prevv`/`preve` 回溯得到一条最小费用路径。
    4. 计算该路径的瓶颈容量 `d`，沿路径增广 `d`，更新 `cap_` 与反向 `cap_`，并累加 `cost += d * edge_cost`，`flow += d`。
    5. 重复步骤 1-4，直到无法再找到增广路径。

- `int main()`
  - 作用：读取输入（`n m`、m 条边、`s t`），初始化 `head`、调用 `ensure_edge_alloc(m)`、插入边并调用 `min_cost_max_flow`，最后把结果 `flow cost` 打印到 stdout。

---

## 五、代码设计思路与实现要点

1. 残量图设计：
   - 使用“并行数组 + 链表索引”形式的邻接表，方便在性能敏感的竞赛环境中减少内存开销与分配次数。
   - 每次插入（原始）边同时插入反向边以表示残量。

2. 路径搜索策略：
   - 当前版本使用 SPFA（基于队列），每轮找到一条最小费用路径后按瓶颈容量增广。SPFA 能处理负权边（只要图不存在可导致无限减费的负环），实现简单直观。
   - 早期实现中包含了 Dijkstra+potentials（势）版本，已保留堆实现作为参考。若图无负权或已用势消除了约化负权，Dijkstra+potentials 在大规模图上通常更稳定高效。

3. 数值与类型：
   - 费用使用 `long long`（typedef 为 `ll`）以减少溢出风险；容量使用 `int`。

4. 边界与健壮性：
   - `ensure_edge_alloc` 只做一次分配，未实现动态扩容；若在运行时需要插入更多边会越界。
   - 输入假定 0-based 节点编号；若需要 1-based 支持可在 `main` 中读入后减 1。

5. 性能与改进建议：
   - 若希望处理大规模稠密图或对性能有严格要求，建议恢复并使用 Dijkstra+potentials：先用 Bellman-Ford/ SPFA 计算初始势，再在约化费用非负的图上用 Dijkstra（优先队列）求短路，整体更快且更可控。
   - 可以把并行数组改为动态向量并在插入时 `realloc` 扩容以增强健壮性。
   - 可添加调试模式打印每轮增广路径/剩余容量/费用，便于教学或排错。

---

## 六、快速使用示例

在项目根目录下：

```bash
gcc -std=c11 -O2 Mcmf/mcmf.c -o Mcmf/mcmf
printf "4 4\n0 1 3 1\n1 3 2 2\n0 2 2 2\n2 3 2 1\n0 3\n" | Mcmf/mcmf
# 输出： 4 12
```

---

## 七、算法复杂度分析

### 7.1 时间复杂度

本实现采用的是 **SPFA（Shortest Path Faster Algorithm）+ 连续增广** 的策略。下面针对代码实现进行逐行复杂度分析。

#### 代码实现分析

**主函数 `min_cost_max_flow` 的结构**：

```c
while (1) {  // 外层循环：增广轮数
    // 1. 初始化 dist, prevv, preve, inqueue 数组
    for (int i = 0; i < N; ++i) { ... }  // O(n)
    
    // 2. SPFA 寻找最小费用路径
    while (qhead != qtail) {  // SPFA 主循环
        int v = queue[qhead++];
        for (int e = head[v]; e != -1; e = next_[e]) {  // 遍历邻接边
            if (cap_[e] > 0 && 松弛成功) {
                // 更新 dist, prevv, preve
                // 必要时将节点入队
            }
        }
    }
    
    // 3. 检查是否找到增广路径
    if (prevv[t] == -1) break;  // O(1)
    
    // 4. 计算瓶颈容量
    for (int v = t; v != s; v = prevv[v]) { ... }  // O(n)
    
    // 5. 沿路径增广
    for (int v = t; v != s; v = prevv[v]) { ... }  // O(n)
}
```

#### 详细复杂度分析

设：
- `n` = 顶点数
- `m` = 边数（代码中实际存储 `2m` 条边：正向边 + 反向边）
- `f` = 最终最大流值
- `F` = 增广轮数（实际执行的 while 外层循环次数）

**单轮增广的时间开销**：

1. **数组初始化**（第 1 步）：
   ```c
   for (int i = 0; i < N; ++i) {
       dist[i] = INF;
       prevv[i] = -1;
       preve[i] = -1;
       inqueue[i] = 0;
   }
   ```
   - 复杂度：**O(n)**
   - 每轮必须执行

2. **SPFA 最短路计算**（第 2 步）：
   ```c
   while (qhead != qtail) {
       int v = queue[qhead++];
       inqueue[v] = 0;
       for (int e = head[v]; e != -1; e = next_[e]) {
           if (cap_[e] <= 0) continue;
           int to = to_[e];
           if (dist[to] > dist[v] + cost_[e]) {
               dist[to] = dist[v] + cost_[e];
               prevv[to] = v;
               preve[to] = e;
               if (!inqueue[to]) {
                   inqueue[to] = 1;
                   queue[qtail++] = to;
               }
           }
       }
   }
   ```
   
   - **平均情况**：O(m)
     - 每个节点平均入队常数次（通常 1-2 次）
     - 总边松弛次数约为 O(m)
   
   - **最坏情况**：O(nm)
     - 每个节点可能被入队 O(n) 次
     - 总操作次数：O(n) × O(m) = O(nm)
     - 这种情况在特殊构造的图中出现（如包含大量负权边的图）

3. **路径回溯与增广**（第 4-5 步）：
   ```c
   // 找瓶颈容量
   for (int v = t; v != s; v = prevv[v]) {
       if (cap_[preve[v]] < d) d = cap_[preve[v]];
   }
   // 增广
   for (int v = t; v != s; v = prevv[v]) {
       int e = preve[v];
       cap_[e] -= d;
       cap_[e ^ 1] += d;
       cost += (ll)d * cost_[e];
   }
   ```
   - 复杂度：**O(路径长度)** = **O(n)**
   - 最短路径最多经过 n 个节点

**单轮增广总复杂度**：
- 平均情况：O(n) + O(m) + O(n) = **O(n + m)**
- 最坏情况：O(n) + O(nm) + O(n) = **O(nm)**

#### 总体时间复杂度

**增广轮数 F 的界限**：

1. **理论上界**：F ≤ f
   - 每次增广至少推送 1 单位流量
   - 最大流为 f 时，最多需要 f 轮

2. **实际表现**：F << f
   - 每次沿最小费用路径增广时，瓶颈容量通常 > 1
   - 对于容量分布较均匀的图，F 通常远小于 f
   - 经验值：F ≈ O(√f) 到 O(f/log f)

**总体复杂度**：

| 情况 | 单轮复杂度 | 增广轮数 | 总复杂度 |
|------|-----------|---------|---------|
| **平均情况** | O(m) | F ≈ O(√f) | **O(m√f)** |
| **最坏情况** | O(nm) | F = O(f) | **O(nmf)** |
| **稀疏图**（m=O(n)） | O(n) | F ≈ O(√f) | **O(n√f)** |

**代码实现特点对复杂度的影响**：

1. **环形队列**：
   ```c
   int capq = N * 5 + 5;
   queue[qtail++] = s;
   if (qtail == capq) qtail = 0;
   ```
   - 使用固定大小的环形缓冲区（5n+5）
   - 避免动态分配，常数因子小
   - 空间局部性好，缓存友好

2. **按位异或找反向边**：
   ```c
   cap_[e ^ 1] += d;  // e^1 是 e 的反向边
   ```
   - 利用边按对存储的特性（正向边索引为偶数，反向边为奇数）
   - O(1) 时间找到反向边，无需额外查找

3. **邻接表遍历**：
   ```c
   for (int e = head[v]; e != -1; e = next_[e])
   ```
   - 只遍历实际存在的边，不访问不存在的边
   - 对稀疏图非常高效

### 7.2 空间复杂度

下面针对代码中实际分配的每一块内存进行分析。

#### 全局/静态空间

1. **图结构（邻接表）**：
   ```c
   int *head;           // 大小: n
   int *to_, *next_;    // 大小: 2m+5（每条原始边对应正反两条）
   int *cap_;           // 大小: 2m+5
   ll *cost_;           // 大小: 2m+5
   ```
   - **head 数组**：`sizeof(int) × n` ≈ 4n 字节
   - **边数组**：`sizeof(int) × 3 × (2m+5) + sizeof(ll) × (2m+5)`
     - to_, next_, cap_: 各 4(2m+5) 字节
     - cost_: 8(2m+5) 字节
     - 总计：≈ **20m + 100** 字节
   
   **小计**：**O(n + m)** 空间，精确为 `4n + 20m + 100` 字节

2. **堆数组**（预留，当前未使用）：
   ```c
   Pair *heap_arr;  // 未在 main 中分配，保留接口
   ```
   - 当前实现不分配：**0 字节**

#### 函数内动态分配（min_cost_max_flow）

```c
ll *dist = malloc(sizeof(ll) * N);         // 8n 字节
int *prevv = malloc(sizeof(int) * N);      // 4n 字节
int *preve = malloc(sizeof(int) * N);      // 4n 字节
int *inqueue = malloc(sizeof(int) * N);    // 4n 字节
```

**小计**：**20n** 字节

#### 每轮增广内的临时分配

```c
int capq = N * 5 + 5;
int *queue = malloc(sizeof(int) * capq);   // 4(5n+5) = 20n+20 字节
```

- 每轮分配一次，用完立即释放
- 峰值额外空间：**20n + 20** 字节

#### 总空间占用分析

| 组件 | 大小（字节） | 生命周期 |
|------|------------|---------|
| head 数组 | 4n | 整个程序 |
| 边数组（4个） | 20m + 100 | 整个程序 |
| dist, prevv, preve, inqueue | 20n | min_cost_max_flow 函数期间 |
| SPFA 队列 | 20n + 20 | 单轮增广期间 |
| **峰值总和** | **44n + 20m + 120** | - |

**渐进复杂度**：**O(n + m)**

**精确空间**（以 int=4B, long long=8B 计）：
- 假设 n=1000, m=5000
- 空间占用 ≈ 44×1000 + 20×5000 + 120 = 144,120 字节 ≈ **140 KB**

#### 实现优化说明

1. **避免重复分配**：
   ```c
   ensure_edge_alloc(m);  // 一次性分配，不动态扩容
   ```
   - 优点：避免 realloc 开销，预分配提高性能
   - 缺点：必须预知边数，不支持动态添加边

2. **栈上分配 vs 堆分配**：
   - 代码选择在堆上分配所有数组（malloc）
   - 好处：支持大规模图（栈空间通常有限）
   - 对于小图（n < 10000），可考虑用 VLA（Variable Length Array）减少分配开销

3. **内存布局**：
   - 并行数组（to_, next_, cap_, cost_）而非结构体数组
   - 优点：更好的缓存局部性，遍历单个属性时更快
   - 缺点：代码可读性稍差

### 7.3 代码性能特征分析

基于实际实现的性能特征分析：

#### 当前实现的性能优势

1. **简洁的数据结构**：
   ```c
   // 并行数组 + 链表索引
   for (int e = head[v]; e != -1; e = next_[e]) {
       int to = to_[e];
       int cap = cap_[e];
       ll cost = cost_[e];
   }
   ```
   - 内存布局紧凑，缓存命中率高
   - 避免指针追踪，CPU 分支预测友好

2. **常数优化**：
   ```c
   cap_[e ^ 1] += d;  // 反向边索引通过异或获得，O(1)
   ```
   - 边对存储（偶数索引正向，奇数索引反向）
   - 避免额外的反向边查找表

3. **环形队列实现**：
   ```c
   queue[qtail++] = to;
   if (qtail == capq) qtail = 0;
   ```
   - 避免队列元素移动
   - 固定大小，无动态扩容开销

#### 性能瓶颈识别

通过代码分析，主要性能瓶颈在于：

1. **SPFA 的不确定性**：
   ```c
   while (qhead != qtail) {
       int v = queue[qhead++];
       for (int e = head[v]; e != -1; e = next_[e]) {
           // 每个节点可能多次入队
       }
   }
   ```
   - 节点重复入队次数不可控
   - 最坏情况：每个节点入队 O(n) 次
   - 建议：添加入队次数统计，超过阈值时切换算法

2. **每轮重新初始化**：
   ```c
   for (int i = 0; i < N; ++i) {
       dist[i] = INF;
       prevv[i] = -1;
       ...
   }
   ```
   - 即使图很稀疏，也要初始化所有 n 个节点
   - 优化建议：使用时间戳标记，避免全局清零

3. **队列内存分配**：
   ```c
   int *queue = malloc(sizeof(int) * capq);
   // ... SPFA ...
   free(queue);
   ```
   - 每轮增广都要 malloc/free
   - 优化：在 min_cost_max_flow 外层分配一次，重复使用

#### 针对实现的优化建议

**优化 1：避免重复初始化**
```c
// 当前实现
for (int i = 0; i < N; ++i) dist[i] = INF;

// 优化方案：时间戳技术
static ll stamp = 0;
static ll *timestamp;  // timestamp[v] 记录 dist[v] 的有效轮次
++stamp;
// 只在访问时检查：if (timestamp[v] != stamp) { dist[v] = INF; timestamp[v] = stamp; }
```
- 避免 O(n) 的初始化
- 实际访问节点远少于 n 时效果显著

**优化 2：队列复用**
```c
// 在 min_cost_max_flow 开始处分配一次
int *queue = malloc(sizeof(int) * (N * 5 + 5));
while (1) {
    // 使用 queue，但不每轮 free/malloc
}
free(queue);  // 函数结束时释放
```
- 减少 F 次 malloc/free 调用（F 为增广轮数）

**优化 3：早期终止检测**
```c
if (dist[t] >= INF) break;  // 汇点不可达
// 当前代码用 prevv[t] == -1 判断，等价但稍慢
```

**优化 4：限制 SPFA 入队次数**
```c
int *enqueue_count = calloc(N, sizeof(int));
while (qhead != qtail) {
    int v = queue[qhead++];
    if (++enqueue_count[v] > N) {
        // 检测到可能的负环或性能退化
        // 可切换到 Bellman-Ford 或报错
    }
    // ...
}
```

#### 实际场景性能预测

基于代码实现特点，不同场景下的预期性能：

| 图类型 | n | m | 预期增广轮数 | 单轮时间 | 总时间估计 |
|--------|---|---|-------------|---------|-----------|
| 稀疏随机图 | 1000 | 3000 | ~50 | O(m) | ~150K 操作 |
| 稠密随机图 | 500 | 50000 | ~100 | O(m) | ~5M 操作 |
| 网格图 | 1000 (32×32) | 2000 | ~200 | O(m) | ~400K 操作 |
| 退化情况 | 100 | 500 | ~1000 | O(nm) | ~50M 操作 |

**实测建议**：
- 使用 `run_benchmark.sh` 对不同规模图测试
- 关注增广轮数 F 与理论上界 f 的比值
- 统计 SPFA 的平均节点入队次数

### 7.4 复杂度验证与实验分析

#### 验证方法

使用 `run_benchmark.sh` 脚本进行实验验证。该脚本会：
1. 生成不同规模的随机图
2. 编译并运行 `mcmf.c`
3. 记录运行时间和内存使用
4. 将结果保存到 `benchmark_results.csv`

#### 实验设计

**实验 1：验证单轮 SPFA 复杂度 O(m)**

固定增广轮数（控制流量），改变边数：
```bash
# 生成 n=1000，m 从 2000 到 20000 的图
# 控制容量使增广轮数固定为 ~10 轮
```
预期：运行时间与 m 成线性关系

**实验 2：验证增广轮数影响**

固定图结构，改变容量分布：
```bash
# 相同的图结构（n=1000, m=5000）
# 情况 A：所有边容量为 1（增广轮数 = 流量值）
# 情况 B：边容量为随机大值（增广轮数远小于流量值）
```
预期：情况 A 运行时间显著大于情况 B

**实验 3：验证空间复杂度 O(n+m)**

通过监控内存使用（需要 `/usr/bin/time -v`）：
```bash
# n 和 m 同比例增长
# 检查内存使用是否与 44n + 20m 的公式吻合
```

#### 实验数据记录

建议在 benchmark 中添加以下统计信息（修改代码添加调试输出）：

```c
// 在 min_cost_max_flow 中添加计数器
int augment_count = 0;      // 增广轮数
long long spfa_ops = 0;     // SPFA 松弛操作总数
int max_enqueue = 0;        // 单个节点最大入队次数

while (1) {
    augment_count++;
    int cur_enqueue_max = 0;
    // ... SPFA ...
    // 统计本轮操作数
}

fprintf(stderr, "Augments: %d, SPFA_ops: %lld, Avg_ops/round: %lld\n", 
        augment_count, spfa_ops, spfa_ops/augment_count);
```

#### 预期实验结果

| 指标 | 理论值 | 实验预期 | 验证方法 |
|------|--------|---------|---------|
| 单轮时间 | O(m) | 线性拟合 R² > 0.95 | 固定 F，变化 m |
| 总时间 | O(Fm) | 二元线性拟合 | 同时变化 F 和 m |
| 增广轮数 | ≤ f | F ≈ 0.1f ~ 0.5f | 对比 F 与 flow |
| 内存使用 | 44n+20m | 误差 < 10% | 实测 vs 公式 |
| 节点入队次数 | 平均 < 2n | 统计 histogram | 添加计数器 |

#### 实际性能示例

基于典型网络流图的预期性能（单核 Intel i5-8250U @ 1.6GHz）：

```
n=100,   m=500:    < 1ms    (小规模)
n=500,   m=2500:   ~5ms     (中等规模)
n=1000,  m=5000:   ~20ms    (常见竞赛规模)
n=5000,  m=25000:  ~200ms   (大规模)
n=10000, m=50000:  ~800ms   (接近实用上限)
```

**性能分界点**：
- n < 1000：性能优秀，SPFA 几乎不退化
- 1000 < n < 5000：性能良好，适合大多数应用
- n > 5000：建议考虑 Dijkstra+势函数优化

#### 复杂度验证脚本示例

```bash
#!/bin/bash
# complexity_test.sh - 验证时间复杂度

echo "n,m,flow,time_ms" > complexity_results.csv

for n in 100 200 500 1000 2000; do
    m=$((n * 5))  # 保持 m/n = 5
    for trial in {1..5}; do
        # 生成测试数据
        python3 -c "
import random
print(f'{n} {m}')
for _ in range({m}):
    u, v = random.randint(0, {n}-1), random.randint(0, {n}-1)
    cap = random.randint(1, 100)
    cost = random.randint(1, 100)
    print(f'{u} {v} {cap} {cost}')
print('0', {n}-1)
        " > test_input.txt
        
        # 运行并计时
        start=$(date +%s%N)
        result=$(./mcmf < test_input.txt)
        end=$(date +%s%N)
        time_ms=$(( (end - start) / 1000000 ))
        flow=$(echo $result | cut -d' ' -f1)
        
        echo "$n,$m,$flow,$time_ms" >> complexity_results.csv
    done
done

# 用 gnuplot 或 python 绘制 time vs n*m 的图
```

---

## 八、测试脚本说明

本仓库包含若干用于验证正确性与基准测试的脚本，该脚本由 GPT 辅助生成，位于 `Mcmf/` 目录：

- `run_correctness_tests.sh`：正确性测试脚本。
  - 功能：生成多组随机中等规模有向图，分别用 C 程序 `Mcmf/mcmf` 与 Python 参考实现 `Mcmf/mcmf_ref.py` 计算最小费用最大流，并比较两者输出（flow 与 cost）。
  - 用法：在项目根目录运行：

    ```bash
    bash run_correctness_tests.sh
    ```

  - 输出：脚本会在 `Mcmf/correctness_tests/` 下生成输入/输出文件，并在发现不一致时把失败用例保存为 `fail_*` 文件以便调试。

- `run_benchmark.sh`：性能基准测试脚本。
  - 功能：为多组不同规模生成随机图，编译并运行 `Mcmf/mcmf`，记录每次运行的耗时（和在支持 `/usr/bin/time` 时的峰值内存），将汇总写入 `Mcmf/benchmark_results.csv`，并将每次输入/输出日志保存在 `Mcmf/benchmark_logs/`。
  - 用法：在项目根目录运行：

    ```bash
    bash Mcmf/run_benchmark.sh
    ```

  - 可配置项：脚本顶部的 `N_LIST`、`AVG_DEG`、`REPEATS`、`TIMEOUT_SEC` 可根据机器性能调整。

在使用这些脚本前，请确保已编译 C 可执行文件或让脚本自动编译（脚本会尝试编译）。

---

欢迎pr
