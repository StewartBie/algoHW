# 最小费用最大流（MCMF）算法实现

本文档说明 `mcmf.c` 的算法设计思路、输入输出格式、运行方法以及复杂度分析。

## 算法概述

本程序实现最小费用最大流（Min-Cost Max-Flow）算法，采用 **SPFA + 连续增广** 策略：
- 每轮使用 SPFA（队列优化的 Bellman-Ford）在残量图中寻找最小费用增广路径
- 沿找到的路径增广尽可能多的流量
- 重复直到无增广路径

## 算法设计思路

### 核心思想

1. **残量图表示**：
   - 使用并行数组实现的邻接表存储图
   - 每条原始边 u→v 同时插入正向边（容量 c，费用 w）和反向边（容量 0，费用 -w）
   - 反向边用于记录已推送的流量，支持流的回退

2. **最小费用路径搜索**：
   - 使用 SPFA 算法在残量图中寻找从源点到汇点的最小费用路径
   - SPFA 能处理负权边，适合 MCMF 场景
   - 维护 dist[] 记录最小费用，prevv[]/preve[] 记录前驱路径

3. **流量增广**：
   - 沿找到的最小费用路径回溯，计算瓶颈容量（路径上最小剩余容量）
   - 沿路径更新正向边和反向边的容量
   - 累加流量和费用

### 算法流程

```
初始化：flow = 0, cost = 0
while (true):
    1. 使用 SPFA 在残量图中寻找从 s 到 t 的最小费用路径
    2. 如果找不到路径，算法结束
    3. 沿路径回溯，找瓶颈容量 d（路径上最小剩余容量）
    4. 沿路径增广流量 d，更新边的容量
    5. flow += d, cost += d × 路径费用
返回 (flow, cost)
```

### 数据结构设计

**邻接表（并行数组实现）**：
```c
int *head;      // head[u] = 节点 u 的第一条边索引，-1 表示无边
int *to_;       // to_[e] = 边 e 的终点
int *next_;     // next_[e] = 与边 e 同起点的下一条边索引
int *cap_;      // cap_[e] = 边 e 的剩余容量
ll *cost_;      // cost_[e] = 边 e 的单位费用
```

**设计优势**：
- 内存布局紧凑，缓存友好
- 只遍历实际存在的边，对稀疏图高效
- 按位异或快速访问反向边：`e^1` 是边 `e` 的反向边（边成对存储，偶数索引为正向，奇数索引为反向）

## 输入输出格式

### 输入格式

**标准输入**（从 stdin 读取）：

```
第 1 行：n m          # 顶点数、边数（节点编号 0-based）
第 2~m+1 行：u v cap cost  # 每行一条边
第 m+2 行：s t        # 源点、汇点
```

**参数说明**：
- `n`：顶点数（整数）
- `m`：边数（整数）
- `u, v`：边的起点和终点（整数，0 ≤ u,v < n）
- `cap`：边的容量（整数）
- `cost`：单位流量费用（长整数）
- `s, t`：源点和汇点（整数）

**输入示例**：
```
4 4
0 1 3 1
1 3 2 2
0 2 2 2
2 3 2 1
0 3
```

### 输出格式

**标准输出**（输出到 stdout）：

```
flow cost
```

- `flow`：从源点到汇点的最大流量（长整数）
- `cost`：达到最大流时的最小总费用（长整数）

**输出示例**：
```
4 12
```

解释：最大流为 4，对应的最小费用为 12。

## 如何运行

### 编译

在项目根目录下执行：

```bash
gcc -std=c11 -O2 Mcmf/mcmf.c -o Mcmf/mcmf
```

### 运行

**方式 1：从文件读取输入**
```bash
./Mcmf/mcmf < input.txt
```

**方式 2：管道输入**
```bash
echo "4 4
0 1 3 1
1 3 2 2
0 2 2 2
2 3 2 1
0 3" | ./Mcmf/mcmf
```

**方式 3：交互式输入**
```bash
./Mcmf/mcmf
# 然后手动输入数据
```

### 快速测试

```bash
# 编译并测试
gcc -std=c11 -O2 Mcmf/mcmf.c -o Mcmf/mcmf
printf "4 4\n0 1 3 1\n1 3 2 2\n0 2 2 2\n2 3 2 1\n0 3\n" | ./Mcmf/mcmf
# 预期输出：4 12
```

## 正确性测试

### 自动测试脚本

运行正确性测试脚本（需要 Python 3 和参考实现 `mcmf_ref.py`）：

```bash
bash Mcmf/run_correctness_tests.sh
```

**测试内容**：
- 生成多组随机测试用例（不同规模的有向图）
- 分别用 C 实现和 Python 参考实现计算结果
- 比对两者的输出（最大流和最小费用）
- 测试用例保存在 `Mcmf/correctness_tests/` 目录

**输出说明**：
- ✓ 表示测试通过
- ✗ 表示测试失败（会保存失败用例到 `fail_*.in`）

### 手动验证

可以使用在线工具或其他 MCMF 实现验证结果：
1. 使用相同输入运行多个实现
2. 比对最大流值和最小费用
3. 检查费用是否为全局最优

## 算法复杂度分析

### 时间复杂度

本实现采用 **SPFA + 连续增广** 策略。

**符号定义**：
- `n` = 顶点数
- `m` = 边数
- `f` = 最大流值
- `F` = 实际增广轮数

**单轮增广的时间开销**：

1. **数组初始化**：O(n)
   - 初始化 dist[], prevv[], preve[], inqueue[] 数组

2. **SPFA 最短路计算**：
   - 平均情况：**O(m)**（每个节点平均入队 1-2 次）
   - 最坏情况：**O(nm)**（每个节点可能入队 O(n) 次）

3. **路径回溯与增广**：O(n)
   - 找瓶颈容量：O(路径长度) ≤ O(n)
   - 沿路径增广：O(路径长度) ≤ O(n)

**单轮总复杂度**：
- 平均：O(n + m) ≈ **O(m)**
- 最坏：**O(nm)**

**增广轮数 F**：
- 理论上界：F ≤ f（每次至少推送 1 单位流量）
- 实际表现：F << f（每次推送的流量通常 > 1）
- 经验值：F ≈ O(√f) 到 O(f/log f)

**总体时间复杂度**：

| 情况 | 单轮复杂度 | 增广轮数 | 总复杂度 |
|------|-----------|---------|---------|
| **平均情况** | O(m) | F ≈ O(√f) | **O(m√f)** |
| **最坏情况** | O(nm) | F = O(f) | **O(nmf)** |
| **稀疏图** (m=O(n)) | O(n) | F ≈ O(√f) | **O(n√f)** |

**实现优化特点**：
- 环形队列：避免动态分配，O(1) 入队出队
- 异或找反向边：`cap_[e^1] += d`，O(1) 时间
- 邻接表遍历：只访问实际存在的边

### 空间复杂度

**全局空间（图存储）**：
```c
int *head;              // 4n 字节
int *to_, *next_, *cap_; // 3 × 4(2m+5) 字节
ll *cost_;              // 8(2m+5) 字节
```
总计：**4n + 20m + 100** 字节

**函数工作空间**（min_cost_max_flow 函数内）：
```c
ll *dist;               // 8n 字节
int *prevv, *preve, *inqueue;  // 3 × 4n 字节
int *queue;             // 4(5n+5) 字节（每轮分配）
```
总计：**20n + 20** 字节（每轮）

**总空间复杂度**：**O(n + m)**

精确峰值：**44n + 20m + 120** 字节

**空间示例**：
- n=1000, m=5000：约 140 KB
- n=5000, m=25000：约 720 KB
- n=10000, m=50000：约 1.4 MB

### 性能特征


**预期运行时间**（单核 Intel i5）：
```
n=100,   m=500     < 1ms
n=500,   m=2500    ~5ms
n=1000,  m=5000    ~20ms
n=5000,  m=25000   ~200ms
n=10000, m=50000   ~800ms
```

**性能瓶颈**：
1. SPFA 的不确定性（节点可能多次入队）
2. 每轮重新初始化 O(n) 数组
3. 增广轮数依赖于容量分布

### 复杂度验证

可以通过修改代码添加统计信息验证复杂度：

```c
// 在 min_cost_max_flow 中添加
int augment_count = 0;      // 增广轮数
long long spfa_ops = 0;     // SPFA 松弛操作总数

// 输出统计信息
fprintf(stderr, "Augments: %d, Ops: %lld, Avg: %lld\n", 
        augment_count, spfa_ops, spfa_ops/augment_count);
```

---

**编译选项说明**：
- `-std=c11`：使用 C11 标准
- `-O2`：开启优化（推荐）
- 可添加 `-Wall` 查看警告

**兼容性**：
- GCC 4.7+
- Clang 3.1+
- 需要 C11 或更高版本编译器
